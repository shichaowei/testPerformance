// Autogenerated code. Do not modify.
package com.fengdai.qa.testMemory;

import com.fengdai.qa.testMemory.Person;
import java.util.EnumSet;
import java.util.Objects;
import java.util.function.UnaryOperator;
import javax.annotation.Generated;

/** Auto-generated superclass of {@link Person.Builder}, derived from the API of {@link Person}. */
@Generated("org.inferred.freebuilder.processor.CodeGenerator")
abstract class Person_Builder {

  /** Creates a new builder using {@code value} as a template. */
  public static Person.Builder from(Person value) {
    return new Person.Builder().mergeFrom(value);
  }

  private enum Property {
    NAME("name"),
    AGE("age"),
    ;

    private final String name;

    private Property(String name) {
      this.name = name;
    }

    @Override
    public String toString() {
      return name;
    }
  }

  private String name;
  private int age;
  private final EnumSet<Person_Builder.Property> _unsetProperties =
      EnumSet.allOf(Person_Builder.Property.class);

  /**
   * Sets the value to be returned by {@link Person#name()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code name} is null
   */
  public Person.Builder name(String name) {
    this.name = Objects.requireNonNull(name);
    _unsetProperties.remove(Person_Builder.Property.NAME);
    return (Person.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Person#name()} by applying {@code mapper} to it and
   * using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public Person.Builder mapName(UnaryOperator<String> mapper) {
    Objects.requireNonNull(mapper);
    return name(mapper.apply(name()));
  }

  /**
   * Returns the value that will be returned by {@link Person#name()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public String name() {
    if (_unsetProperties.contains(Person_Builder.Property.NAME)) {
      throw new IllegalStateException("name not set");
    }
    return name;
  }

  /**
   * Sets the value to be returned by {@link Person#age()}.
   *
   * @return this {@code Builder} object
   */
  public Person.Builder age(int age) {
    this.age = age;
    _unsetProperties.remove(Person_Builder.Property.AGE);
    return (Person.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Person#age()} by applying {@code mapper} to it and
   * using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public Person.Builder mapAge(UnaryOperator<Integer> mapper) {
    Objects.requireNonNull(mapper);
    return age(mapper.apply(age()));
  }

  /**
   * Returns the value that will be returned by {@link Person#age()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public int age() {
    if (_unsetProperties.contains(Person_Builder.Property.AGE)) {
      throw new IllegalStateException("age not set");
    }
    return age;
  }

  /** Sets all property values using the given {@code Person} as a template. */
  public Person.Builder mergeFrom(Person value) {
    Person_Builder _defaults = new Person.Builder();
    if (_defaults._unsetProperties.contains(Person_Builder.Property.NAME)
        || !Objects.equals(value.name(), _defaults.name())) {
      name(value.name());
    }
    if (_defaults._unsetProperties.contains(Person_Builder.Property.AGE)
        || !Objects.equals(value.age(), _defaults.age())) {
      age(value.age());
    }
    return (Person.Builder) this;
  }

  /**
   * Copies values from the given {@code Builder}. Does not affect any properties not set on the
   * input.
   */
  public Person.Builder mergeFrom(Person.Builder template) {
    // Upcast to access private fields; otherwise, oddly, we get an access violation.
    Person_Builder base = template;
    Person_Builder _defaults = new Person.Builder();
    if (!base._unsetProperties.contains(Person_Builder.Property.NAME)
        && (_defaults._unsetProperties.contains(Person_Builder.Property.NAME)
            || !Objects.equals(template.name(), _defaults.name()))) {
      name(template.name());
    }
    if (!base._unsetProperties.contains(Person_Builder.Property.AGE)
        && (_defaults._unsetProperties.contains(Person_Builder.Property.AGE)
            || !Objects.equals(template.age(), _defaults.age()))) {
      age(template.age());
    }
    return (Person.Builder) this;
  }

  /** Resets the state of this builder. */
  public Person.Builder clear() {
    Person_Builder _defaults = new Person.Builder();
    name = _defaults.name;
    age = _defaults.age;
    _unsetProperties.clear();
    _unsetProperties.addAll(_defaults._unsetProperties);
    return (Person.Builder) this;
  }

  /**
   * Returns a newly-created {@link Person} based on the contents of the {@code Builder}.
   *
   * @throws IllegalStateException if any field has not been set
   */
  public Person build() {
    if (!_unsetProperties.isEmpty()) {
      throw new IllegalStateException("Not set: " + _unsetProperties);
    }
    return new Person_Builder.Value(this);
  }

  /**
   * Returns a newly-created partial {@link Person} for use in unit tests. State checking will not
   * be performed. Unset properties will throw an {@link UnsupportedOperationException} when
   * accessed via the partial object.
   *
   * <p>Partials should only ever be used in tests. They permit writing robust test cases that won't
   * fail if this type gains more application-level constraints (e.g. new required fields) in
   * future. If you require partially complete values in production code, consider using a Builder.
   */
  public Person buildPartial() {
    return new Person_Builder.Partial(this);
  }

  private static final class Value implements Person {
    private final String name;
    private final int age;

    private Value(Person_Builder builder) {
      this.name = builder.name;
      this.age = builder.age;
    }

    @Override
    public String name() {
      return name;
    }

    @Override
    public int age() {
      return age;
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof Person_Builder.Value)) {
        return false;
      }
      Person_Builder.Value other = (Person_Builder.Value) obj;
      return Objects.equals(name, other.name) && Objects.equals(age, other.age);
    }

    @Override
    public int hashCode() {
      return Objects.hash(name, age);
    }

    @Override
    public String toString() {
      return "Person{" + "name=" + name + ", " + "age=" + age + "}";
    }
  }

  private static final class Partial implements Person {
    private final String name;
    private final int age;
    private final EnumSet<Person_Builder.Property> _unsetProperties;

    Partial(Person_Builder builder) {
      this.name = builder.name;
      this.age = builder.age;
      this._unsetProperties = builder._unsetProperties.clone();
    }

    @Override
    public String name() {
      if (_unsetProperties.contains(Person_Builder.Property.NAME)) {
        throw new UnsupportedOperationException("name not set");
      }
      return name;
    }

    @Override
    public int age() {
      if (_unsetProperties.contains(Person_Builder.Property.AGE)) {
        throw new UnsupportedOperationException("age not set");
      }
      return age;
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof Person_Builder.Partial)) {
        return false;
      }
      Person_Builder.Partial other = (Person_Builder.Partial) obj;
      return Objects.equals(name, other.name)
          && Objects.equals(age, other.age)
          && Objects.equals(_unsetProperties, other._unsetProperties);
    }

    @Override
    public int hashCode() {
      return Objects.hash(name, age, _unsetProperties);
    }

    @Override
    public String toString() {
      StringBuilder result = new StringBuilder("partial Person{");
      String separator = "";
      if (!_unsetProperties.contains(Person_Builder.Property.NAME)) {
        result.append("name=").append(name);
        separator = ", ";
      }
      if (!_unsetProperties.contains(Person_Builder.Property.AGE)) {
        result.append(separator);
        result.append("age=").append(age);
      }
      result.append("}");
      return result.toString();
    }
  }
}
